'''
문제에서 요구하는 것은 다음과 같다.

바이러스는 입력에서 2로 주어지고, 주어진 바이러스 중에서 M개를 고른다.
초마다 바이러스에 인접한 빈칸은 바이러스 퍼지게 된다.
모든 빈칸에 바이러스가 퍼지는 시간을 구한다.

위 과정을 반복하면서 최소 시간을 찾는다.

일반적으로 DFS, BFS 문제에 익숙하다면, 1번 과정을 위해서 DFS, 2번 과정을 위해서 BFS 를 떠올릴 수 있다.

1번 과정을 위해 최대 10개 중 M개를 고르는 경우들에 대해 2번 과정을 동작해야한다.

* 1번 과정은 조합 공식으로는 10Cm 으로 나타낼 수 있다.

1번은 백트래킹을 통해 쉽게 구현할 수 있다.

바이러스가 위치할 수 있는 M개의 경우에 대해서는 2번 과정을 동작한다.

그렇지 않으면, M개의 경우를 찾기 위해 1번 과정을 다시 재귀적으로 호출한다.

2번 과정은 BFS 를 사용해서 단순히 인접한 네 방향으로 확산시켜주면 된다.
'''
n, m = map(int, input())
lab = [list(map(int, input().split())) for _ in range(n)]

activeVirus = []
inactiveVirus = []

for i in range(n):
    for j in range(n):
        if lab[i][j] == 2:
            activeVirus.append((i, j))

