n, k = map(int, input().split()) # 물품 수 n, 버틸 수 있는 무게 k

stuff = [(0, 0)] # 물품 리스트
dp = [[0]*(k+1) for _ in range(n+1)] # 1~k의 무게를 나타내는 행, 물품의 개수만큼의 열을 가진 dp 테이블

# 물품 리스트에 각 물품 무게, 가치 저장
for i in range(n):
    #stuff.append(list(map(int, input().split())))
    w, v = map(int, input().split())
    stuff.append((w, v))

# 1. 현재 배낭의 허용 무게보다 넣을 물품의 무게가 더 크다면 넣지 않는다.
# 2. 현재 배낭의 허용 무게에 넣을 물품이 들어간다면,
#   2-1. 현재 물품을 넣는다. (현재 넣을 물품의 무게만큼 뺀 배낭의 가치에 현재 물품 가치를 더해 저장한다.)
#   2-2. 현재 물품을 넣지 않고 이전 배낭 그대로 가지고 간다. (이전 물품에서 현재 배낭의 허용 무게에 저장했던 가치를 그대로 저장한다.)
# cf) 현재 넣을 물품의 무게만큼 뺀 배낭에는 그 무게의 배낭이 가지는 최대 가치가 저장되어 있다.

for i in range(1, n+1): # 물품 하나씩
    for j in range(1, k+1): # 1~k의 무게
        w = stuff[i][0] # i 번째 물품 무게
        v = stuff[i][1] # i 번째 물품 가치

        if j < w: # j가 물품의 무게보다 작아서 물품이 들어가지 않는다면
            dp[i][j] = dp[i-1][j] # 이전 물품의 현재 가방 무게 값 저장
        else: # 물품이 들어갈 수 있다면
            # 이전 물품의 현재 가방 무게 값과 현재 물품의 가치 + 이전 물품의 현재 가방-현재 물품 무게 값 비교해서 큰 값 저장
            # dp[i][j] = max(dp[이전 물품][현재 가방 무게], 현재 물품 가치 + dp[이전 물품][현재 가방 무게 - 현재 물품 무게])
            dp[i][j] = max(dp[i-1][j], v+dp[i-1][j-w])

print(dp[n][k])